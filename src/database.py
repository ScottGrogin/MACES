from datetime import date, datetime
from settings import VALID_TABLE_NAMES
import oracledb
import json
from settings import (
    ORACLE_DB_PASSWORD,
    ORACLE_DB_USERNAME,
    ORACLE_HOST,
    ORACLE_PORT,
    ORACLE_SERVICE,
)
from contextlib import contextmanager


def validate_table_name(func):
    def wrapper(table_name, *args, **kwargs):
        cleaned = table_name.strip()

        if cleaned not in VALID_TABLE_NAMES:
            raise ValueError(
                f"Invalid table name '{cleaned}'. "
                f"Allowed tables: {VALID_TABLE_NAMES}"
            )

        return func(cleaned, *args, **kwargs)

    return wrapper


connection_pool = oracledb.create_pool(
    user=ORACLE_DB_USERNAME,
    password=ORACLE_DB_PASSWORD,
    dsn=f"""
        (description=
        (retry_count=20)
        (retry_delay=3)
        (address=(protocol=tcps)(port={ORACLE_PORT})(host={ORACLE_HOST}))
        (connect_data=(service_name={ORACLE_SERVICE}))
        (security=(ssl_server_dn_match=yes))
        )
    """,
    min=2,
    max=2,
    increment=0,
)


@contextmanager
def db_cursor():
    """Yields a (connection, cursor) with auto commit/rollback and cleanup."""
    conn = connection_pool.acquire()
    cursor = conn.cursor()
    try:
        yield conn, cursor
        conn.commit()
    except Exception:
        conn.rollback()
        raise
    finally:
        cursor.close()
        conn.close()


def get_connection():
    return connection_pool.acquire()


def run_query(sql, params=None, commit=False):
    with db_cursor() as (conn, cursor):
        cursor.execute(sql, params or [])
        if commit:
            conn.commit()
        if cursor.description:  # if SELECT
            return cursor.fetchall()


@validate_table_name
def find_rows_by_json_fields(table_name: str, filters: dict):
    _validate_filters(filters)
    where_clauses = []
    params = {}
    for i, (json_path, value) in enumerate(filters.items(), start=1):
        val_key = f"val{i}"
        where_clauses.append(f"JSON_VALUE(data, '{json_path}') = :{val_key}")
        params[val_key] = value

    where_sql = " AND ".join(where_clauses)
    sql = f"SELECT id, data FROM {table_name} WHERE {where_sql}"
    rows = run_query(sql, params)
    return rows


def _validate_filters(filters: dict):
    valid_filter_names = ["$.date", "$.host_park_id"]
    for name, _ in filters.items():
        if name not in valid_filter_names:
            raise ValueError("Invalid filter name")


@validate_table_name
def insert_json_data(table_name: str, data: dict):
    def default_serializer(obj):
        if isinstance(obj, (date, datetime)):
            return obj.isoformat()
        raise TypeError(f"Type {type(obj)} not serializable")

    json_data = json.dumps(data, default=default_serializer)

    run_query(
        f"INSERT INTO {table_name} (data) VALUES (:data)",
        {"data": json_data},
        commit=True,
    )


@validate_table_name
def update_json_data(table_name: str, record_id: int, new_data: dict):
    """Update a row's JSON data by its numeric ID."""
    json_data = json.dumps(new_data)
    sql = f"UPDATE {table_name} SET data = :data WHERE id = :id"
    run_query(sql, {"data": json_data, "id": record_id}, commit=True)


@validate_table_name
def does_table_exist(table_name: str) -> bool:
    result = run_query(
        "SELECT COUNT(*) FROM user_tables WHERE table_name = :name",
        [table_name.upper()],
    )
    return result[0][0] > 0


@validate_table_name
def create_table(table_name: str):
    run_query(
        f"""
        CREATE TABLE {table_name} (
            id NUMBER GENERATED BY DEFAULT AS IDENTITY,
            data CLOB CHECK (data IS JSON)
        )
        """,
        commit=True,
    )


@validate_table_name
def create_table_if_not_exists(table_name: str):
    """Create a table with a JSON column if it doesn't already exist."""

    if does_table_exist(table_name):
        return
    create_table(table_name)
